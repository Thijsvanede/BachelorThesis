\documentclass{sig-alternate-br}

\bibliographystyle{plain}

\usepackage{placeins}
%\floatbarrier
\usepackage{caption}
\captionsetup{labelfont=bf,font=bf}
\usepackage{subcaption}

\usepackage{listings}
\lstset{	numbers=left,
		escapechar=$,
		breaklines=true,
		numbersep=3pt}


\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{invariant}{Invariant}

\title{Certainty in Lockless Concurrent Algorithms: an Informal Proof of Lace}
\author{
	\alignauthor
	Thijs van Ede\\
	\affaddr{University of Twente}\\
	\affaddr{P.O. Box 217, 7500AE Enschede}\\
	\affaddr{The Netherlands}\\
	\affaddr{t.s.vanede@student.utwente.nl}\\
}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
Lockless concurrent programming brings new challenges to the field of program verification.
These lockless programs require methods such as compare-and-swap and memory fences to ensure correctness.
However, their unpredictable behaviour in combination with these methods complicates verifying such algorithms.
We use linearisation points, i.e. the points in time when the state of the system changes, to abstract these methods.
By deducing the possible ordering of these linearisation points we can predict the possible states of the system and draw conclusions about the scrutinised algorithms.
This paper uses linearisation points and the data flow of the program to create an informal proof of the Lace\cite{vanDijk2014206} algorithm, which implements a work-stealing method for concurrent programs.
\end{abstract}

\keywords{Lace, linearisation points, concurrent programming, informal proof}

\section{Introduction}
Modern day processors' multi-core architecture has increased demand for concurrent programming to fully utilise the processing power.
These concurrent programs need to be proven correct to ensure the desired execution.
Several methods for proving programs correct exist such as separation logic\cite{reynolds2002} and first-order logic\cite{smullyan1995}.

Interactive theorem prover tools such as Isabelle\cite{paulson1994isabelle}, Coq\cite{coq2015}, and PVS\cite{owre1992pvs} use various methods of logical based proving check models.
These tools are helpful in proving properties of both sequential\cite{badban2005verification} and concurrent\cite{colvin2006formal} \cite{shankar1993verification} algorithms.
The theorem prover tool PVS uses several decision procedures and a symbolic model checker, in combination with a random tester to help generating formal proofs.

This paper tries to proof several properties of the Lace algorithm\cite{vanDijk2014206} to illustrate a method of proving concurrent programs.
Lace is a concurrent algorithm for thread scheduling among processors.
Its use of a memory fence, compare-and-swap system call and both concurrent and sequential components make it an ideal algorithm to proof correct.

In this paper, we will prove the Lace algorithm correct using the interactive theorem prover tool PVS.
The algorithm is modeled by constructing linearisation points where the state of the system changes, and using them to generate a flow diagram of the program.
Subsequently, PVS assists in proving the required invariants using this model in combination with several assumptions about the system.
With the invariants a comprehensive proof of the Lace algorithm is constructed.

\subsection{Lace}
Lace is a work stealing algorithm\cite{Blumofe1994} which uses a compare-and-swap operation to steal tasks\cite{vanDijk2014206}.
Work stealing algorithms dynamically execute multi-threaded computations.
In this context, each thread is called a worker.
These workers are able to spawn new computational tasks and execute them.
When a worker has got no work of its own it attempts to steal a task from other workers, thereby becoming a thieving thread.
Each worker in Lace has its own deque, i.e. double-ended queue.
A deque can be accessed from both its head and its tail, the process itself operates on the head, whereas stealing threads operate on the tail.
Besides the deque, a worker also holds pointers for the head and tail of the deque, as well as a pointer for a split point.
This split point indicates whether a thieving thread can steal a task or not, i.e. what part of the deque is shared and what part is private.
When the tail is still lower than the split point, thieving threads are allowed to steal this task.
Conversely, when the tail increases beyond the split point thief processes may not steal the task.
Figure \ref{fig:deq} illustrate the workings of this deque with its head, tail, and split variables.
\begin{figure}[h]
	\centering
	\includegraphics[width=8cm]{Lace_Explanation}
	\caption{Example on manipulation of deque variables.}
	\label{fig:deq}
\end{figure}
The deque is presented as an array of slots which may be empty or contain tasks.
Slots containing a task are represented with a $\bullet$.
We say a task is stolen when it is located left of the tail, i.e. tail points to the next task to be stolen.
The bar before the split point indicates that tasks can only be stolen left of the bar or split point.
In the first deque, tail is still to the left of split, we say $tail < split$, and thus tasks can be stolen.
In the second deque,$ tail = split$ which means thief processes may not steal tasks.
However, in Lace, a thieving process can request to move the split point so more tasks can be stolen.
This grow\_shared request issues the deque process to increase the split point if possible, which is shown in the bottom deque.
When the head wants to execute a task, it will pop it off the head of the deque and point its head pointer to the task before that.
However, if $head = split$ it cannot pop a task, therefore it will try to shrink the shared part of the deque.
If this is possible, i.e. if $tail < split$, split will be moved to the left and head can pop more tasks.
The full algorithm of Lace, as used in the paper can be found in the appendix.

\subsection{PVS}
Concurrent programs such as Lace, can be proven in a variety of different ways.
There exist tools for proving concurrent programs such as VerCors\cite{eemcs24905}, but they give rather little feedback on the workings of the program.
That is, these tools state whether a program works correct, it does not give the reason it works correct.
Since Lace is still being developed, it is desirable to develop understanding of the algorithm.
Interactive theorem prover tools such as PVS are ideally suited for this purpose, since they give feedback on required properties of lemmas and require the user to check whether required properties hold.
PVS in particular comes highly recommended for its abilities to proof concurrent programs\cite{colvin2006formal} \cite{shankar1993verification}.
Therefore, this paper uses PVS as interactive theorem prover tool to prove Lace correct.

\section{Preliminaries}
\subsection{System}
This paper assumes the algorithm runs on a shared memory system with the x86 memory model.
This memory model allows the reordering of loads before stores, that is, write operations are buffered before they are stored in memory.
Thus threads might read old values, even though they have been written by other threads.
These writes may not have become globally visible yet, because they are still buffered.
Memory fences are used to flush these write buffers and make changes globally visible.
Memory stores are immediately visible to threads that wrote them, hence they do not require memory fences.

\subsection{Compare-and-swap}
A compare-and-swap (\texttt{cas}) ensures thread safety by simulating an atomic memory operation.
The \texttt{cas} operation takes three parameters as input, namely a \texttt{variable}, an \texttt{expected value}, and a \texttt{replacement value}.
The \texttt{cas} operation compares the value of \texttt{variable} to the \texttt{expected value}. When those values are equal, the \texttt{replacement value} replaces the current value of \texttt{variable} and \texttt{cas} returns \texttt{true}.
If they are not equal, \texttt{variable} retains its current value and \texttt{cas} returns \texttt{false}.
Because of its atomicity, \texttt{cas} ensures only one thread executes successfully when multiple threads invoke \texttt{cas} with the same valid parameters.
\texttt{cas} is used for concurrent programming as it ensures thread safety and provides feedback to executing threads on whether their operation succeeded or not.

\subsection{Linearisation points}
\label{sec:lin}
An important aspect of proving concurrent algorithms is defining linearisation points\cite{herlihy1990}.
These linearisation points are the points in time the state of the system changes.
When reasoning about concurrent programs, information about the state of the system is needed to predict its expected behaviour.
By defining linearisation points, the order in which they occur can be varied and thereby all possible states can be derived.
That is, by varying the order of linearisation points, all possible equivalent sequential programs can be derived, which in turn can be reasoned about.

\subsection{Assumed properties}
First of all, we have four ways of classifying a task.
\begin{definition}A task x exists $\iff$ x < \texttt{head}\end{definition}
\begin{definition}A task x is stolen $\iff$ x < \texttt{tail}\end{definition}
\begin{definition}A task x is shared $\iff$ x < \texttt{split}\end{definition}
\begin{definition}A task x is private $\iff$ x $\geq$ \texttt{split}\end{definition}
In proving Lace correct, this paper assumes there are N workers, each executing a single thread.
Initially, all deques , as well as their \texttt{head, tail,} and \texttt{split} variables are set to 0.
One worker starts with a single task in its deque, i.e. \texttt{head} = 1, whereas the other N-1 workers have no tasks to execute and are therefore stealing threads.
This worker thread is able to spawn tasks using the \texttt{spawn} method in Figure \ref{fig:assumption.code}.
When a worker thread requires the result of a task, it synchronises using the \texttt{sync} method in Figure \ref{fig:assumption.code}, thereby popping the method from its deque.
Since a task spawns other tasks it has to synchronise all tasks before returning, therefore we assume that the number of spawns $\geq$ number of syncs and at the end of each task the number of spawns = number of syncs.
Conversely, stealing threads try to steal tasks from working threads using the forever loop on top of Figure \ref{fig:assumption.code}.
When stealing threads have successfully stolen a task, they become working threads as well, spawning their own tasks.
If a thread runs out of tasks to complete, it becomes a thieving thread executing the thieving loop.
\begin{figure}[h]
\begin{lstlisting}
  thief: forever: {
    status, Task = steal_from_queue()
    if status == stolen
      Task.result = Task.call()
    Task.done = true
  }

  spawn(function, paramters){
    push(Task(function, parameters))
  }

  sync(){
    status, Task = peek()
    if status is Stolen:
      wait until Task.done == true
      res = Task.result
      pop()
    else:
      pop()
      res = Task.call()
    return res
  }
\end{lstlisting}
\caption{The assumed algorithm threads use to steal, spawn, and synchronise tasks respectively.}
\label{fig:assumption.code}
\end{figure}
The assumptions below follow from the statement that methods of Lace are called by the program described above and illustrated in Figure \ref{fig:assumption.code}.
\begin{enumerate}
	\setlength{\itemsep}{-3pt}
	\item One owner thread per deque.
	\item 0 to N-1 stealing threads per deque.
	
	\item \texttt{steal} is only called by thieving threads.
	\item \texttt{push} and \texttt{pop} are only called by owner thread.

	\item Number of \texttt{pop} calls $\leq$ number of \texttt{push} calls.
	\item When finished, number of \texttt{pop} calls = number of \texttt{push} calls.
	
	\item On initialisation all deque variables are set to zero.
\end{enumerate}

\subsection{Required properties}
Lace requires some properties to work correctly.
First of all, the variables \texttt{head}, \texttt{split}, and \texttt{tail} should stay within bounds.
Figure \ref{inv:bounds} expresses this requirement as invariants. 
\begin{figure}[h]
	\texttt{0 $\leq$ head $\leq$ size}\\
	\texttt{0 $\leq$ split $\leq$ head}\\
	\texttt{0 $\leq$ tail $\leq$ head}
	\caption{Invariants: variables stay within bounds.}
	\label{inv:bounds}
\end{figure}
Furthermore, a task must be stolen only once, and executed exactly once.
To prove these properties, they are written as invariants.
When every task is stolen only once, it means thieving threads can only steal tasks $\geq$ \texttt{tail} and that when tail reduces, a task cannot be stolen again. The former part of the property is trivial, if tail increases it steals an unstolen task which is consistent with the requirement. The latter part is less trivial, if tail reduces, a stolen task cannot be executed again, therefore the stolen tasks need to be removed before tail is reduced. This is written as an invariant in Figure \ref{inv:stolen}.
\begin{figure}[h]
	\texttt{tail.new $\geq$ tail.old || (tail.new < tail.old \&\& tail.old-tail.new $\leq$ \#pop() == STOLEN)}
	\caption{Invariant: every task is stolen only once.}
	\label{inv:stolen}
\end{figure}
To elaborate on this invariant: either \texttt{tail} increases when a new task is stolen, or \texttt{tail} decreases with the same amount as the number of \texttt{STOLEN} tasks that are removed. This way an already stolen task cannot be stolen again.
When a task is executed once, this implies it is only stolen once and not executed by the owner thread, or it is executed by the owner thread and never stolen. This can be written as the invariant in Figure \ref{inv:exec}.
\begin{figure}[h]
	\texttt{(pop() == STOLEN \&\& head.new < head.old) || (pop() == WORK \&\& head.new < head.old)}
	\caption{Invariant: every task is executed only once.}
	\label{inv:exec}
\end{figure}

\section{Method}
In proving concurrent programs such as Lace using interactive theorem prover tools, linearisation points of the algorithm must be appointed.
Each linearisation point modifies a variable of the program.
For concurrent programs, each possible state of the system can be derived by altering the order in which the linearisation points occur.
From which conclusions can be drawn about the desired behaviour of the system with respect to the possible behaviour of the system.

The first step of appointing linearisation points is trivial and could be done automatically.
However, because the algorithm is relatively simple and to illustrate how these points can be identified it is done manually.
First all global variables of the algorithm are identified, then each point in the algorithm where a variable is changed is appointed as a linearisation point with the operation that is performed at that point.
This is done for all global variables, i.e. \texttt{head, split, tail, allstolen, movesplit} as well as private variables \texttt{o\_allstolen} and \texttt{o\_split}.

After the linearisation points are established, this paper deduces the order in which they occur.
Therefore, we setup flow diagrams of the methods \texttt{pop} and \texttt{push} to establish the possible orders of linearisation points.
These diagrams include methods invoked within the \texttt{pop} or \texttt{push} method.
No flow diagram is setup for the method \texttt{steal}, since we assume numerous threads execute this method simultaneously which renders a diagram useless.

Finally, we prove the required properties of Lace using several lemmas which base themselves on the linearisation points of the system and the possible order of these points.
For these proofs, the interactive theorem prover tool PVS\cite{owre1992pvs} is used which correctly states whether lemmas hold.
These lemmas, as well as axioms are introduces by the user into PVS.
Within this paper, all lemmas and axioms are deduced from the assumptions about Lace, constructed linearisation points, and their order as described by the flow diagrams.
In this paper, PVS' grind option\cite{PVSProverGuide} is used extensively to proof lemmas within the theorem prover tool.
This option attempts to solve given lemmas automatically using lemmas introduces by the user.
Ultimately, the invariant \texttt{(pop() == STOLEN \&\& head.new < head.old) || (pop() == WORK \&\& head.new < head.old)} is proven which establishes correctness of Lace.

Various interactive theorem prover tools may be used for proving this algorithm correct.
However, this paper uses the PVS 6.0 Allegro Lisp Binary for a Linux Intell 64-bit machine.
The model of the algorithm is constructed from its description in the paper \cite{vanDijk2014206}.

A proof constructed with an interactive theorem prover such as PVS holds in all cases and could also be constructed without using PVS.
The tool only helps to construct the proof and formalise the method of proving algorithms correct.
Therefore, PVS speeds up the process of constructing a proof and increasing confidence in that proof.
It also increases the transferability of this research since the tool constructs equal proofs in an identical way.

\section{Modeling Lace}
A model for the Lace algorithm is constructed from its specifications as described in \cite{vanDijk2014206} and displayed in Figure \ref{fig:Lace}.
Note the that Figure \ref{fig:Lace} projects a slightly different form of the algorithm.
However, this alternate form is used to construct a model for Lace.

\subsection{Linearisation Points}
In Lace, the state of the system depends on variables head, split, and tail.
The linearisation points are defined on these variables and can be found in Table \ref{tab:head}, \ref{tab:split}, and \ref{tab:tail} respectively.
Note that the variables used at linearisation points to change the state of the system are read at a point before they are used.
Thus the value might have changed when the program reaches the linearisation point, in which case it still uses the old value.
In addition to these three main variables, the algorithm also uses a \texttt{movesplit} and \texttt{allstolen} variable.
These variables influence the behaviour of the system by indicating whether the split point must be moved or all public tasks are stolen respectively.
Therefore, these variables are also included in the linearisation points, which can be found in Table \ref{tab:move}, \ref{tab:allst}, and \ref{tab:oallst}.

\subsubsection{Head}
\label{sec:head}
Variable head is modified in both \texttt{push} and \texttt{pop} methods.
Table \ref{tab:head} gives an overview of the linearisation points and the places where the variables used in the linearisation points are initialised.
The first linearisation point is at line 13 of Lace as shown in Figure \ref{fig:Lace}, where \texttt{head} is incremented by 1.
In this case the variable \texttt{head} is read in the same line of code but does not occur simultaneously with the write operation.
The second and third linearisation points are at line 45 and 47 of Lace as shown in Figure \ref{fig:Lace} respectively.
In both cases, \texttt{head} is decreased by 1 and the variable is read in the same line of code as it is written.
As with the first point, the read and write operation do not occur simultaneously.

\subsubsection{Split}
In Lace, the variable \texttt{split} has two instances, namely \texttt{split} and \texttt{o\_split}.
The latter instance of \texttt{split} is private, and thus visible to the owner thread but not to thieving threads.
To avoid confusion, \texttt{split} and \texttt{o\_split} are displayed in Table \ref{tab:split} and Table \ref{tab:osplit} respectively.
Just as explained in section \ref{sec:head} these tables indicate the methods, linearisation points, operations, initialisation points, and variables for the variable scrutinised, in this case the \texttt{split} and \texttt{o\_split} variables.
As opposed to the linearisation points of the variable \texttt{head}, \texttt{split} has linearisation points in which variables are used that are read in a different line of the algorithm.
This might indicate a greater chance of the variables being altered before they are used.

\subsubsection{Tail}
The final variable of the deque that is important to include in the model is \texttt{tail}, its linearisation points can be found in Table \ref{tab:tail}.
This variable is modified in the \texttt{steal} and \texttt{push} functions at lines 5 and 15 respectively.
In \texttt{steal, tail} is read at line 3 whilst incremented at line 5.
Because of this gap tail can be modified in the meantime by other threads.
The same goes for the modification of \texttt{tail} in \texttt{push}, since read and write do not occur simultaneously.

\subsubsection{Movesplit}
\texttt{movesplit} is not part of the deque, but it indicates whether the owner thread should grow the shared part of the deque.
This boolean variable is set to true at line 8 of the algorithm and is set to false at lines 16 and 25.
These linearisation points can be found in Table \ref{tab:move}.

\subsubsection{Allstolen}
As with \texttt{split}, the variable \texttt{allstolen} has two instances, namely \texttt{allstolen} and \texttt{o\_allstolen}.
The global boolean variable \texttt{allstolen} is set to false at line 17 of the algorithm and to true at line 39.
The private \texttt{o\_allstolen} is set to false and true at lines 19 and 40 respectively.
The linearisation points can be found in Table \ref{tab:allst} and \ref{tab:oallst}.
\begin{table}[h]
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin pt} & \textbf{new value} & \textbf{init point} \\ \hline
			push            & 13                 & head+1      & 13               \\ \hline
			pop             & 45                 & head-1      & 45               \\ \hline
			pop             & 47                 & head-1      & 47               \\ \hline
		\end{tabular}
		\caption{Linearisation points of head variable.}
		\label{tab:head}
	\end{subtable}
	\hfill
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin pt} & \textbf{new value} & \textbf{init point} \\ \hline
			push            & 15                 & head        		   & 15\\ \hline
			gr\_shared    & 23                 & new\_s=(o+h+1)/2 & 22\\ \hline
			shr\_shared  & 30                 & new\_s=(t+s)/2      & 27\\ \hline
			shr\_shared  & 36                 & new\_s=(t+s)/2      & t:32,s:27\\ \hline
		\end{tabular}
		\caption{Linearisation points of split variable.}
		\label{tab:split}
	\end{subtable}
	\hfill
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin pt} & \textbf{new value} & \textbf{init point}\\ \hline
			push            & 18                 & head        & 18\\ \hline
			gr\_shared    & 24                 & new\_s=(o+h+1)/2      & 22\\ \hline
			shr\_shared  & 37                 & new\_s=(t+s)/2      & 27\\ \hline
			shr\_shared  & 37                 & new\_s=(t+s)/2      & t:32,s:27\\ \hline
		\end{tabular}
		\caption{Linearisation points of o\_split variable.}
		\label{tab:osplit}
	\end{subtable}
	\hfill
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin point} & \textbf{new value} & \textbf{init point}\\ \hline
			steal           & 5                  & t+1         & 3\\ \hline
			push            & 15                 & head-1      & 15\\ \hline
		\end{tabular}
		\caption{Linearisation points of tail variable}
		\label{tab:tail}
	\end{subtable}
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin point} & \textbf{new value} & \textbf{init point}\\ \hline
			steal           & 8                  & true        & 8                   \\ \hline
			push            & 16                 & false       & 16                  \\ \hline
			grow\_shared    & 25                 & false       & 25             \\ \hline
		\end{tabular}
		\caption{Linearisation points of movesplit variable}
		\label{tab:move}
	\end{subtable}
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin point} & \textbf{new value} & \textbf{init point}\\ \hline
			push            & 17                 & false       & 17                  \\ \hline
			shrink\_shared  & 39                 & true        & 39               \\ \hline
		\end{tabular}
		\caption{Linearisation points of allstolen variable}
		\label{tab:allst}
	\end{subtable}
	\begin{subtable}[h]{0.45\textwidth}
		\centering
		\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{method} & \textbf{lin point} & \textbf{new value} & \textbf{init point} \\ \hline
			push            & 19                 & false       & 19                 \\ \hline
			shrink\_shared  & 40                 & true        & 40            \\ \hline
		\end{tabular}
		\caption{Linearisation points of o\_allstolen variable}
		\label{tab:oallst}
	\end{subtable}
	\caption{The method column indicates the method where the variable is modified. Lin pt column refers to the linearisation point in the Lace algorithm as shown in Figure \ref{fig:Lace}. The op column explains the executed operation. The final column init point refers to the point in the Lace algorithm where the variables are read. Note that in \ref{tab:split} and \ref{tab:osplit} o\_split and head are abbreviated to o, h respectively. Tail and split are abbreviated to t and s since these is a local variables as in the algorithm.}
	\label{tab:linpoints}
\end{table}

\subsection{Order of linearisation points}
By assuming only one owner thread exclusively calls methods \texttt{push} and \texttt{pop}, all variables manipulated only at those methods will occur in order.
Subsequently, this is true for all methods \texttt{grow\_shared} and \texttt{shrink\_shared} which are invoked only through \texttt{push} and \texttt{pop}.
The natural order of linearisation points called by \texttt{push} and \texttt{pop} can be derived by creating a flow diagram.
In this section, the order of linearisation points for \texttt{push} and \texttt{pop} are derived respectively.

First of all, the method \texttt{push} has a flow diagram as depicted in Figure \ref{fig:push}.
Here the first linearisation point is at line 13, where head is increased.
If \texttt{o\_allstolen} is set, the program continues with linearisation point 15.
Then, if \texttt{movesplit} is true, it is set to false, otherwise it continues flowing through all linearisation points down to linearisation point 19 where \texttt{o\_allstolen} is set to false.
Alternatively, when \texttt{o\_allstolen} is false at line 14 and \texttt{movesplit} is true at line 20, it invokes the method \texttt{grow\_shared} which is depicted as the right part of the flow diagram.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{Push_flow_diagram_2.png}
	\caption{Flow diagram of method push.}
	\label{fig:push}
\end{figure}

Second, the method \texttt{pop} has a flow diagram as depicted in Figure \ref{fig:pop}.
This diagram is less trivial than the \texttt{push} flow diagram.
Since the method \texttt{pop} first checks whether \texttt{head} equals 0 and returns when it does, the linearisation points are not reached, thus the first condition of \texttt{head $\neq$ 0} is introduced.
After this, it checks whether \texttt{o\_allstolen} is set, if this is the case, it continues to decrease \texttt{head} and returns.
Alternatively, if \texttt{o\_allstolen} is \texttt{false}, it checks whether \texttt{o\_split == head}, if so, it calls the method \texttt{shrink\_shared} following the rhombus' upper arrow.
The method \texttt{shrink\_shared} first checks whether the variables \texttt{t} and \texttt{s} that it read from \texttt{tail} and \texttt{split} respectively are equal.
If this condition is true, it sets \texttt{allstolen} and \texttt{o\_allstolen} after which it returns true and continues at \texttt{pop}.
Subsequently, if the condition is false, it modifies \texttt{split} and sets a memory fence, depicted with the dashed lines.
After reading the \texttt{tail} variable into \texttt{t} again, the algorithm checks whether \texttt{t} equals \texttt{s}.
When they are equal, the method sets the \texttt{allstolen} variables, and returns true, after which it continues at \texttt{pop}.
However, when they are not equal, \texttt{t} and the temporary variable \texttt{new\_s} are compared.
If \texttt{t $>$ new\_s}, \texttt{split} is modified, otherwise only \texttt{o\_split} is set to \texttt{new\_s}.
Thereafter, the method returns false and continues at \texttt{pop}.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.25]{Pop_flow_diagram_2.png}
	\caption{Flow diagram of method pop.}
	\label{fig:pop}
\end{figure}

From these flow diagrams, the possible sequences of linearisation points are clear.
Note that the linearisation points modified by thieving threads through the method \texttt{steal} are not included.
Since these occur at arbitrary points in the algorithm, it does not make sense to include them in a flow chart.

\section{Proving Lace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				allstolen = o_allstolen					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	\texttt{o\_allstolen = allstolen} at every point where \texttt{o\_allstolen} is used.
	\label{lem:allstolen}
\end{lemma}
\begin{proof}
	Table \ref{tab:allst} and \ref{tab:oallst} indicate that both \texttt{allstolen} variables only change through methods \texttt{push} and \texttt{shrink\_\\shared}.
	Figure \ref{fig:push} states that private variable \texttt{o\_split} is the only variable to change in between the modifications to \texttt{false} of the \texttt{allstolen} variables.
	Subsequently, Figure \ref{fig:pop} states there are no linearisation points between the modifications to \texttt{true} at all.
	No load operations of \texttt{allstolen} or \texttt{o\_allstolen} occur in between either modification of the variables.
	The assumed memory model where loads can be reordered before stores does not influence this Lemma, since Table \ref{tab:allst} states stealing threads only use \texttt{allstolen}.
	The owner thread does not reorder both \texttt{allstolen} variables, because the thread itself is the only thread modifying them.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%					split = o_split					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	\texttt{o\_split = split} at every point where \texttt{o\_split} is used.
	\label{lem:split}
\end{lemma}
\begin{proof}
	Table \ref{tab:split} and \ref{tab:osplit} affirm that both \texttt{split} variables only change through methods \texttt{push}, \texttt{grow\_shared}, and \texttt{shrink\_shared}.
	Figure \ref{fig:push} indicates that private variable \texttt{movesplit} and \texttt{allstolen} are modified between the linearisation points of both \texttt{split} variables.
	Furthermore, Figure \ref{fig:pop} states that between linearisation points 23 and 24 no reads of either split variable occur.
	Between linearisation point 30 of \texttt{split} and 37 of \texttt{o\_split} there are no read operations for either \texttt{split} variable.
	In addition, between linearisation point 36 of \texttt{split} and linearisation point 37 of \texttt{o\_split} there are no read operations on \texttt{split}.	
	The x86 memory model where loads can be reordered before stores is not important for this Lemma, since the method \texttt{steal} only uses \texttt{split}.
	Whereas the owner thread uses \texttt{o\_split}, but loads cannot be reordered before stores for the thread that executes the stores.		
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				    0 <= head < size					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{invariant}
	\texttt{0 $\leq$ head $\leq$ size}.
	\label{lem:headsize}
\end{invariant}
\begin{proof}
	Table \ref{tab:head} indicates \texttt{head} is only increased at method \texttt{push} and decreased at the method \texttt{pop}.
	This indicates there is no need to take the reordering of loads before stores into account, since only one thread operates on this variable.
	Since we assume \texttt{head} = 0 at the start of the algorithm, i.e. \texttt{0 $\leq$ head $\leq$ size}, it is left to prove linearisation point 13 cannot increase \texttt{head} beyond \texttt{size}.
	Subsequently, we prove linearisation points 45 and 47 cannot decrease \texttt{head} to a value lower than 0.
	Linearisation point 13 increases \texttt{head} by 1.
	By inspection of line 11 of Lace we find \texttt{head $\neq$ size}, in combination with the assumption that \texttt{head $\leq$ size}, \texttt{head < size} holds.
	This implies \texttt{head+1 $\leq$ size} for which this invariant holds.
	Both linearisation point 45 and 47 decrease \texttt{head} by 1, and upon inspection of Figure \ref{fig:pop} we find line 43 of \texttt{head == 0} precedes both points.
	Thus \texttt{head $\geq$ 0} and \texttt{head $\neq$ 0} implies \texttt{head > 0}.
	Therefore \texttt{0 $\leq$ head-1}, proving the invariant.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		  tail+1 ==> !allstolen && t=tail < s=split 			%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	\texttt{tail} can only increase by exactly 1 if\\\texttt{$\neg$allstolen} and \texttt{t < s} and \texttt{t = tail} and \texttt{s = split}
	\label{lem:incrtail}
\end{lemma}
\begin{proof}
	The only linearisation point where \texttt{tail} is increased is at the \texttt{cas} operation of line 5 as stated in Table \ref{tab:tail}.
	This modification only succeeds if \texttt{cas} succeeds, i.e. if the compare-and-swap method returns true.
	That is, \texttt{t = tail} and \texttt{s = split}.
	Furthermore, line 4 states \texttt{t < s} for which neither variable can change at any point since they are local to the method.
	Opposed to \texttt{t} and \texttt{s} not changing, \texttt{allstolen} can be modified after it is checked at line 2.
	However, Lemma \ref{lem:allst.incrtail} explains a change in \texttt{allstolen} is caught before the \texttt{cas} operation is executed, ensuring this Lemma holds.	
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	      Linearisation point 30 => split.new <= split.old 	 	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	The modification \texttt{split = new\_s = (t+s)/2} at line 30 of Lace $\Rightarrow$ \texttt{split.new $\leq$ split.old}.
	\label{lem:lin30}
\end{lemma}
\begin{proof}
	According to Figure \ref{fig:pop}, \texttt{split} cannot be modified in between the read operation of \texttt{split}.
	In addition, \texttt{tail $\leq$ split} for when \texttt{tail} is increased at line 5 it is increased to \texttt{t+1} where \texttt{t} < split.
	Table \ref{tab:split} indicates \texttt{split} can only be decreased to \texttt{head} at line 18 of Lace.
	However, \texttt{tail} is simultaneously set to \texttt{head-1}, i.e. lower than \texttt{tail}.
	Moreover, Lemma \ref{lem:grshr} proves the modification at line 24 increases \texttt{split}.
	Therefore we conclude \texttt{tail $\leq$ split}.
	Thus line 30 states \texttt{split.new = new\_s = t+s/2 = tail+split.old/2 $\leq$ 2*split.old/2 $\leq$ split.old},\\since \texttt{t = tail} and \texttt{s = split}.
	This proves Lemma \ref{lem:lin30}.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	      Linearisation point 36 => split.new <= split.old 	 	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	The modification \texttt{split = new\_s = (t+1)/2} at Line 36 of Lace $\Rightarrow$ \texttt{split.new $\leq$ split.old}, where \texttt{split.old} is before line 30 of Lace.
	\label{lem:lin36}
\end{lemma}
\begin{proof}
	Figure \ref{fig:pop} states line 30 precedes line 36 in Lace.
	Lemma \ref{lem:lin30} indicates \texttt{split} decreases at line 30, however, the memory fence of line 31 making this modification globally visible might be too late so that \texttt{tail} has increased beyond the new \texttt{split}.
	As described in the proof of Lemma \ref{lem:lin30}, \texttt{tail} cannot increase further than \texttt{split.old}.
	Therefore the newly read value of \texttt{tail} at line 32 ensures \texttt{tail.new $\leq$ split}, where \texttt{split} is the modification after line 30.
	Now the modification of line 36 can be interpreted as \texttt{split.new = (t+s)/2 $\leq$ 2*split.old/2 $leq$ split.old}, proving Lemma \ref{lem:lin36}.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			Global visibility min(lin 30, lin 36)			 	%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
	The lowest value of \texttt{split}, as modified by lines 30 and 36 is globally visible after the modification of line 36.
	\label{lem:lin3036}
\end{lemma}
\begin{proof}	
	Figure \ref{fig:pop} affirms line 30 is reached before line 36 and a memory fence is executed in between the executions of both lines.
	It is left to prove line 36 does not decrease the value of \texttt{tail}, with respect to the modification of line 30.
	The operations of both linearisation points are equal, they are set to \texttt{new\_s} where \texttt{new\_s = (t+s)/2}.
	In the latter modification the value of \texttt{t} is reread from \texttt{tail} at line 32, i.e. after the memory fence, all other variables are equal.
	Table \ref{tab:tail} states, \texttt{tail} is only modified at lines 5 and 15 by \texttt{steal} and \texttt{push} respectively.
	The only modification is the increase of \texttt{tail}, since \texttt{push} is only called from within the owner thread, and not in between lines 30 and 36.
	Therefore, \texttt{t.new $\geq$ t.old} which means \texttt{split.30 = (t.old+split.old)/2 $\leq$ (t.new+split.old)/2}	
\end{proof}

\begin{lemma}
	\texttt{shrink\_shared} returns \texttt{false} and \texttt{tail $\leq$ head} $\Rightarrow$ \texttt{tail $\leq$ split < head}.
	\label{lem:shrsh.var}
\end{lemma}
\begin{proof}
	Figure \ref{fig:pop} affirms \texttt{shrink\_shared} (represented by linearisation points 30, 36, and 37) is only called if \texttt{o\_split = split = head} (Lemma \ref{lem:split}).
	Furthermore, the Figure states \texttt{shrink\_shared} only returns \texttt{false} if \texttt{t != s}, i.e. \texttt{tail $\neq$ head}, since \texttt{split = head} and there occur no modifications to either variables in the meantime.
	Lemmas \ref{lem:lin30} and \ref{lem:lin36} state \texttt{tail} can only decrease at these points. 
	Combined with the assumption that \texttt{split $\neq$ head} it follows that \texttt{tail $\leq$ split < head}.
\end{proof}

\begin{lemma}
	\texttt{grow\_shared} is only called if \texttt{$\neg$allstolen}
	\label{lem:grshr}
\end{lemma}
\begin{proof}
	Figure \ref{fig:pop} specifies that \texttt{grow\_shared}, represented by linearisation point 23, can only be reached if \texttt{$\neg$o\_all-stolen}.
	Furthermore, it shows no linearisation points modifying \texttt{o\_allstolen} occur after \texttt{o\_allstolen} is checked.
	Table \ref{tab:allst} and \ref{tab:oallst} state both variables can only be changed by the owner thread.
	In combination with Lemma \ref{lem:allstolen} we conclude that \texttt{grow\_shared} is only called if $\neg$\texttt{allstolen}.
\end{proof}

\begin{lemma}
	\texttt{$\neg$allstolen $\Rightarrow$ tail $\leq$ split $\leq$ head}
	\label{lem:allst.var}
\end{lemma}
\begin{proof}
	This paper assumes that the deque is initialised with \texttt{tail = split = head = 0} and \texttt{$\neg$allstolen}, hence, the lemma holds at at initialisation.
	Table \ref{tab:allst} indicates \texttt{allstolen} is only reset at linearisation point 17.
	Figure \ref{fig:push} shows linearisation points 15 of \texttt{tail} and \texttt{split} must precede the reset of \texttt{allstolen}, which set \texttt{tail} and \texttt{split} to \texttt{head-1} and \texttt{head} respectively.
	At this point the lemma still holds, and modifications of \texttt{head, tail,} and \texttt{split} need be scrutinised.
	First of all we note that \texttt{tail} might be modified in between linearisation points 15 and linearisation point 17.
	However, \texttt{tail} will never increase beyond \texttt{split} because of the condition \texttt{t < s} described in Lemma \ref{lem:incrtail}.
	
	Table \ref{tab:tail} demonstrates variable \texttt{tail} is modified at linearisation point 5 and 15.
	Lemma \ref{lem:incrtail} states that for linearisation point 5 to execute \texttt{t < s} and \texttt{t == tail} and \texttt{s = split}.
	Therefore, \texttt{t < split} and \texttt{tail} is set to \texttt{t+1}, i.e. \texttt{tail.new = t+1 $\leq$ split}.
	Figure \ref{fig:push} expounds linearisation point 15 cannot be reached if \texttt{$\neg$ o\_allstolen}, because Lemma \ref{lem:allstolen} states \texttt{o\_allstolen = allstolen} at load operations, this linearisation point cannot be reached when \texttt{$\neg$allstolen}.
	
	Table \ref{tab:split} indicates \texttt{split} is modified at linearisation points 15, 23, 30, and 36.
	As with linearisation point 15 of \texttt{tail}, linearisation point 15 is unreachable when \texttt{$\neg$allstolen}.
	Linearisation point 23 can be reached, Lemma \ref{lem:lin23} states that after this linearisation point \texttt{split $\leq$ head} still holds, using the assumption of this Lemma, that \texttt{$\neg$allstolen $\Rightarrow$ split $\leq$ head}.
	Linearisation point 30 may violate the lemma, since \texttt{tail} can grow to the value of \texttt{split.old} and Lemma \ref{lem:lin30} expounds \texttt{split.new $\leq$ split.old} after the modification of linearisation point 30.
	However linearisation point 36 restores the value \texttt{split} so that \texttt{tail $\leq$ split} holds.
	If \texttt{tail} grows beyond the value of \texttt{split.tmp} as split is set to at line 30, the newly read variable \texttt{t}, which we call \texttt{tail.new}, is larger than \texttt{(tail.old+split.old)/2}, i.e. the value of \texttt{split.tmp}.
	If the newly read variable \texttt{t}, which we call \texttt{tail.new}, is larger than \texttt{(tail.old + split.old)/2}, i.e. the value of \texttt{split} after linearisation point 30, \texttt{tail} violates this lemma.
	According to Figure \ref{fig:pop}, this initiates linearisation point 36 which ensures \texttt{tail.new = (tail.new + split.old)/2}.
	\texttt{tail.new < split.old} holds for line 33 ensures \texttt{t != s}, i.e. \texttt{tail.new $\neq$ split.old}, and linearisation point 5 cannot increase \texttt{tail} beyond \texttt{split}.
	Therefore, \texttt{tail.new < (tail.new+split.old)/2}.	
	
	Table \ref{tab:head} states linearisation points 12, 45, and 47 modify \texttt{head}.
	Of these linearisation points 45 and 47 decrease head and may violate the Lemma, whereas linearisation point 13 increases head posing no danger of violation.
	Figure \ref{fig:pop} states linearisation point 45 is reached, only if \texttt{o\_allstolen} is set, since \texttt{o\_allstolen} cannot be altered by any other than the owner thread according to Table \ref{tab:allst}.
	Combined with Lemma \ref{lem:allstolen}, this linearisation point cannot be reached unless \texttt{allstolen} is set, thus this Lemma is not applicable to the linearisation point.
	Conversely, linearisation point 47 can still be reached.
	In this case, \texttt{shrink\_shared} must have returned \texttt{false}, indicating that \texttt{split < head} (Lemma \ref{lem:shrsh.var}).
	This linearisation point decreases head by 1, therefore \texttt{split < head} implies \texttt{split $\leq$ head-1} and the lemma holds.
	
	This proves that for all linearisation points modifying \texttt{tail, split,} and \texttt{head} the Lemma still holds.
\end{proof}

\begin{lemma}
	Linearisation point 23 does not increase\\\texttt{split} beyond \texttt{head}.
	\label{lem:lin23}
\end{lemma}
\begin{proof}
	Lemma \ref{lem:grshr} affirms $\neg$ \texttt{allstolen} holds when \texttt{grow-\_shared} is invoked.
	Table \ref{tab:allst} shows \texttt{allstolen} is not altered between the invocation of \texttt{grow\_shared} and linearisation point 23.
	From Lemma \ref{lem:allst.var} we now conclude \texttt{split $\leq$ head}.
	Furthermore, Lemma \ref{lem:split} states \texttt{o\_split = split} at each point where \texttt{o\_split} is used.
	This implies the modification \texttt{split.new = (o\_split.old+head+1)/2 = (split.old+head+1)/2}.
	Where \texttt{split.old $\leq$ head} implying \texttt{split.new $\leq$ head} for the equation is a floor function and the +1 cannot increase the numerator to \texttt{2*head+2} since \texttt{split.new $\leq$ head}.
	Therefore linearisation point 23 does not increase \texttt{split} beyond \texttt{head}.
\end{proof}

\begin{lemma}
	Invoking \texttt{pop()} decreases \texttt{head} with exactly 1
	\label{lem:pop.head}
\end{lemma}
\begin{proof}
	Table \ref{tab:head} shows \texttt{head = head-1} can only be invoked from within the method \texttt{pop}, hence \texttt{head.new = head.old-1 $\Rightarrow$ pop()} holds.
	Figure \ref{fig:pop} shows it is impossible to go from linearisation point 45 to 47 or vise versa. Furthermore, the Figure shows both linearisation points are the first possible end states to reach. However, the Figure does state that neither linearisation points are reached when \texttt{head == 0}. Though this is not aplicable to this situation since we assume the number of \texttt{pop} calls never exceed the number of \texttt{push} calls. Therefore \texttt{pop() $\Rightarrow$ head.new = head.old -1} holds.
\end{proof}

\begin{lemma}
	\texttt{shrink\_shared} returns \texttt{True} $\Rightarrow$ \texttt{allstolen} and \texttt{o\_allstolen}.
	\label{lem:shrinkshared}
\end{lemma}
\begin{proof}
	Table \ref{tab:allst} and \ref{tab:oallst} indicate both \texttt{allstolen} variables can only be modified within the methods \texttt{push} and \texttt{shrink\_shared}. Since both can only be called by the owner thread, they cannot be run simultaneously.  Thus, only \texttt{shrink\_shared} needs to be inspected. The return \texttt{true} statement of \texttt{shrink\_shared} corresponds to linearisation point 40 in Figure \ref{fig:pop}, which is preceded by linearisation point 39. Since no more linearisation points occur between that point and the return true statement, the \texttt{allstolen} variables are \texttt{true}. Note that stealing threads might not receive this modification of \texttt{allstolen} before they read the value since this paper assumes a system with the x86 memory model.
\end{proof}

\begin{lemma}
	If \texttt{head} decreases and \texttt{pop} returns \texttt{STOLEN} this implies \texttt{allstolen} is set.
	\label{lem:popstolen}
\end{lemma}
\begin{proof}
	Figure \ref{fig:pop} illustrates \texttt{pop = STOLEN} in combination with the decrement of \texttt{head} as linearisation point 45, which can only be reached if \texttt{o\_allstolen} or (\texttt{o\_split == head} and \texttt{shrink\_shared = true}).
	The latter implies \texttt{o\_allstolen} is \texttt{true} according to Lemma \ref{lem:shrinkshared}.
	Either proposition of the if-statement requires \texttt{o\_allstolen} to be set and therefore \texttt{allstolen} to be set (Lemma \ref{lem:allstolen}).
\end{proof}

\begin{lemma}
	Linearisation point 23 does not decrease \texttt{split}.
	\label{lem:growincrsplit}
\end{lemma}
\begin{proof}
	Table \ref{tab:split} states \texttt{grow\_shared} invokes linearisation point 23.
	In addition, Lemma \ref{lem:grshr} implies \texttt{$\neg$allstolen} when \texttt{grow\_shared} is invoked.
	Table \ref{fig:pop} indicates \texttt{allstolen} is not altered within this method, therefore we can assume \texttt{$\neg$allstolen} at linearisation point 23.
	Lemma \ref{lem:allst.var} suggests that \texttt{$\neg$allstolen $\Rightarrow$ tail $\leq$ split $\leq$ head}, therefore we can assume \texttt{head $\geq$ split}.
	Linearisation point 23 sets split to \texttt{(split+head+1)/2}, from Lemma \ref{lem:allst.var} we know \texttt{head $\geq$ split} implying \texttt{split.new $\geq$ split.old} proving this Lemma.
\end{proof}

\begin{lemma}
	If \texttt{allstolen} is \texttt{true}, \texttt{tail} cannot increase
	\label{lem:allst.incrtail}
\end{lemma}
\begin{proof}
	Table \ref{tab:tail} affirms \texttt{tail} only increases at linearisation point 5 of Lace and Lemma \ref{lem:incrtail} states that \texttt{allstolen} must be false to increase \texttt{tail}.
	Table \ref{tab:allst} shows that \texttt{allstolen} can only be set to true at line 39 of Lace.	
	However, the x86 memory model might not have globalised the modification of \texttt{allstolen}, or has globalised the variable after the stealing method checked it.
	Subsequently, the stealing thread reads \texttt{tail} and \texttt{split} into \texttt{t} and \texttt{s} respectively, and checks whether \texttt{t < s}, a requirement which is also stated in Lemma \ref{lem:incrtail}.	
	Figure \ref{fig:pop} expounds \texttt{allstolen} can be modified if \texttt{t == s}, either at line 28 or line 33.
	This means \texttt{tail = split} since they are read from the memory.
	Stealing threads read the same variables \texttt{tail} and \texttt{split} into their \texttt{t} and \texttt{s} respectively.
	By Lemma \ref{lem:incrtail}, \texttt{tail} cannot increase, endorsing this Lemma.
	These \texttt{tail} and \texttt{split} variables are globally visible, for linearisation point 23 increases \texttt{split}(Lemma \ref{lem:growincrsplit}) and a decrease in \texttt{split} is made globally visible according to Lemma \ref{lem:lin3036}.
	The update of \texttt{split} is globally visible before the update of \texttt{allstolen} therefore stealing threads which have missed the update of \texttt{allstolen} might still be stopped at line 5 where they check whether \texttt{t < s}.	
	Now two scenarios can occur, either the update of \texttt{split} is made globally visible between line 4 and linearisation point 5, or it is made globally visible after linearisation point 5 has occured.
	In the former case, \texttt{cas} ensures the operation of increasing \texttt{tail} fails, since \texttt{split $\neq$ s}, for split is updated whereas the local variable \texttt{s} is equal to the one read at line 3.
	In the latter case, \texttt{tail} has either grown beyond \texttt{split}, in which case linearisation point 36 ensures \texttt{split} is restored to a valid value as stated in Lemma \ref{lem:lin36}, or \texttt{tail} $\leq$ new value of \texttt{split}.
	Figure \ref{fig:pop} affirms that in this case \texttt{allstolen} will not be set and this Lemma is not applicable.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				  Ultimate goal lemma			 		%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%TODO from here on further.
\begin{invariant}
	\texttt{tail.new $\geq$ tail.old or\\(tail.new < tail.old} and \texttt{tail.old-tail.new $\leq$ \#pop() == STOLEN)}
	\label{lem:tail}
\end{invariant}
\begin{proof}
	The first part of the lemma states that \texttt{tail} should increase, this is true for all linearisation points except at line 15 of Lace, as described in Table \ref{tab:tail}.
	The second part states, that if \texttt{tail} is decreased, it decreases by the same amount as the number of calls to \texttt{pop} returning \texttt{STOLEN}.
	Upon scrutinisation of linearisation point 15, we find \texttt{tail} is set to \texttt{head-1}.
	We find \texttt{tail = head.old}, where \texttt{head.old} is the value of \texttt{head} before \texttt{push} is called.
	Since \texttt{head} is only modified by the owner thread (Table \ref{tab:head}) and due to the linear nature of \texttt{push}, linearisation point 13 came before linearisation point 15 (Figure \ref{fig:push}).
	Thus the decrease of \texttt{head} when \texttt{tail} is set to \texttt{head-1} cancels out the increase of \texttt{head} at linearisation point 13.
	
	Now, we must establish that once \texttt{pop} returns \texttt{STOLEN}, it is not possible for \texttt{tail} to increase.
	Note that this is not necessarily true for the invariant to hold, but it is convenient for the lemma to be proven.
	Lemma \ref{lem:popstolen} states that \texttt{allstolen} is true in the described scenario, i.e. \texttt{head} is decreased and \texttt{pop} returns \texttt{STOLEN}.
	Along with Lemma \ref{lem:allst.incrtail}, we find it impossible for \texttt{tail} to increase once \texttt{pop} returned stolen.
	
	Because Lemma \ref{lem:pop.head} states \texttt{pop} decreases \texttt{head} with exactly 1, the number of \texttt{pop() = STOLEN} corresponds to the number of decreases of head.
	According to Table \ref{tab:allst} and Figure \ref{fig:push} \texttt{allstolen} cannot be reset unless preceded by linearisation point 15.
	Therefore, \emph{x} consecutive calls to \texttt{pop} returning \texttt{STOLEN} correspond to \emph{x} decreases of head by 1.
	Thus, when linearisation point 15 is executed, \texttt{tail.old-tail.new = head.old-head.new}, where \texttt{head.old} is the value of \texttt{head} before the first \texttt{pop() = STOLEN} and \texttt{head.new} is the value of \texttt{head} after the last \texttt{pop() = STOLEN}.
	This proves Lemma \ref{lem:tail} correct.
\end{proof}

\begin{invariant}
	\texttt{(pop() == STOLEN and head.new < head.old) || (pop() == WORK and head.new < head.old)}
	\label{inv:exec}
\end{invariant}
\begin{proof}
	Lemma \ref{lem:pop.head} expounds invoking \texttt{pop} always decreases \texttt{head}.
	Furthermore, we assumed the number of calls to \texttt{pop} never exceed the number of calls to \texttt{push}, meaning \texttt{pop} never returns \texttt{EMPTY}.
	Upon inspection of \texttt{pop} we find this method either returns \texttt{STOLEN} or \texttt{WORK}, thereby proving the invariant.
\end{proof}

\subsection{Correctness}
As the required properties stated two invariants needed to be proven to establish correctness of Lace.
Invariant \texttt{tail.new $\geq$ tail.old} or \texttt{(tail.new < tail.old} and \texttt{tail.old-tail.new $\leq$ \#pop() == STOLEN)} was proven by Invariant \ref{lem:tail}, using Lemmas \ref{lem:popstolen}, \ref{lem:allst.incrtail}, and \ref{lem:pop.head}, as well as Table \ref{tab:linpoints} and flow diagrams \ref{fig:push} and \ref{fig:pop}.
This proves each stolen task is only stolen once.
Invariant \texttt{(pop() == STOLEN and head.new < head.old) || (pop() == WORK and head.new < head.old)} was proven by Invariant \ref{inv:exec} using Lemma \ref{lem:pop.head} and the assumed property that the number of calls to \texttt{pop} never exceed the number of calls to \texttt{push}.
From this invariant we conclude each task is executed exactly once, since the previous Invariant states each task is stolen only once.
Thus, the synchronisation method from the assumed algorithm invoking the deque methods sees the task was stolen, waits until it finished and uses the result without computing it again.
Conversely, when the synchronisation method finds a task is not yet executed, it executes the task itself and then uses the result.
Hereby we have proven each task is executed exactly once as stated as a required property.

\section{Conclusion}
This study focused on proving the algorithm Lace correct using linearisation points and their control flow.
Hereby we constructed an informal proof establishing correctness in both required invariants.
I.e. we found \texttt{tail} either increases or stays equal or it is decreased by the same amount of \texttt{pops} that return \texttt{STOLEN}, proving that each task is only stolen once.
Furthermore we have proven each task is executed exactly once by proving Invariant \ref{inv:exec}.
By these proofs we have shown it is possible to proof the required properties of concurrent algorithms using linearisation points and their control flow.
Concurrent operations such as compare-and-swap and memory fences have properties that are sufficient to prove the correctness of a concurrent program.
This paper gains further insights in the correlation between these methods and their effect on lockless concurrent algorithms such as Lace.
It shows the correctness of the algorithm depends on the atomic properties of \texttt{cas} and the assurance of memory fences that each buffered write is made globally visible.
However the constructed proof is an informal proof, i.e. it is not generated or checked by any theorem prover tool.
Hence, the presented proof is intended as a basis for creating a formal proof that ensures Lace's correctness.

\subsection{Future work}
This paper suggests to use theorem prover tools such as VerCors\cite{eemcs24905}, PVS\cite{owre1992pvs} or Isabelle\cite{paulson1994isabelle} to generate a formal proof for Lace.
A formal proof can be generated on the basis of this paper using these theorem prover tools.
Such proof creates certainty in the correctness of Lace allowing the algorithm to be used more widespread.
In addition to creating a formal proof, other variations of Lace can be scrutinised, e.g. variations where stealing threads can steal multiple tasks instead of one.
These might increase performance of Lace, but need to be proven correct separately since this paper limits itself to thieving threads stealing one task at the time.

\bibliography{Bibliography}

\appendix
\section{Lace algorithm}
This paper uses the Lace algorithm as given in Figure \ref{fig:Lace}.
All assumptions, linearisation points, flow diagrams and lemma's are based on this algorithm as described in "Lace: Non-blocking Split Deque for Work-Stealing"\cite{vanDijk2014206}.
\begin{figure}
\begin{lstlisting}
def steal():
  if allstolen: return NOWORK
  (t,s) = (tail,split) $\emph{\#t, s are local}$
  if t < s:
    if cas((tail,split), (t,s), (t+1,s)):
      return WORK(t)
    else: return NONE $\emph{\#busy}$
  elif not movesplit: movesplit = 1
  return NONE $\emph{\#no work}$
\end{lstlisting}
\begin{lstlisting}[firstnumber=10]
def push(data):
  if head == size: return FULL
  $\emph{\#write task data at deque head}$
  head = head + 1
  if o_allstolen:
    (tail,split) = (head-1,head)
    if movesplit: movesplit = 0
    allstolen = 0
    o_split = head
    o_allstolen = 0
  elif movesplit: grow_shared()
\end{lstlisting}
\begin{lstlisting}[firstnumber=21]
def grow_shared():
  new_s = (o_split+head+1)/2
  split = new_s
  o_split = new_s
  movesplit = 0
\end{lstlisting}
\begin{lstlisting}[firstnumber=26]
def shrink_shared():
  (t,s) = (tail,split)
  if t != s:
    new_s = (t+s)/2
    split = new_s
    MFENCE
    t = tail $\emph{\#read again}$
    if t != s:
      if t > new_s:
        new_s = (t+s)/2
        split = new_s
      o_split = new_s
      return FALSE
  allstolen = 1
  o_allstolen = 1
  return TRUE
\end{lstlisting}
\begin{lstlisting}[firstnumber=42]
def pop():
  if head == 0: return EMPTY, None
  if o_allstolen or (o_split == head and shrink_shared()):
    head = head-1
    return STOLEN, head
  head = head-1
  if movesplit: grow_shared()
  return WORK, head
\end{lstlisting}
\caption{Lace algorithm as described in "Lace: Non-blocking Split Deque for Work-Stealing"\cite{vanDijk2014206}}
\label{fig:Lace}
\end{figure}

\end{document}